
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">logstash-platform/internal/agent/core/agent.go (70.0%)</option>
				
				<option value="file1">logstash-platform/internal/agent/logstash/controller.go (8.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "os"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
        "logstash-platform/internal/agent/config"
        "logstash-platform/internal/platform/models"
)

// Agent 实现AgentCore接口
type Agent struct {
        config      *config.AgentConfig
        logger      *logrus.Logger
        
        // 核心组件
        apiClient    APIClient
        configMgr    ConfigManager
        logstashCtrl LogstashController
        heartbeat    HeartbeatService
        metrics      MetricsCollector
        
        // 状态信息
        status       *models.Agent
        statusMutex  sync.RWMutex
        
        // 生命周期管理
        ctx          context.Context
        cancel       context.CancelFunc
        wg           sync.WaitGroup
        
        // WebSocket消息通道
        msgChan      chan *WebSocketMessage
        
        // 启动时间
        startTime    time.Time
}

// NewAgent 创建新的Agent实例
func NewAgent(cfg *config.AgentConfig, logger *logrus.Logger) (*Agent, error) <span class="cov8" title="1">{
        // 获取本机IP
        ip, err := getLocalIP()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Warn("获取本机IP失败，使用127.0.0.1")
                ip = "127.0.0.1"
        }</span>
        
        // 获取主机名
        <span class="cov8" title="1">hostname, err := getHostname()
        if err != nil </span><span class="cov0" title="0">{
                logger.WithError(err).Warn("获取主机名失败")
                hostname = "unknown"
        }</span>
        
        // 初始化Agent状态
        <span class="cov8" title="1">agent := &amp;Agent{
                config:    cfg,
                logger:    logger,
                msgChan:   make(chan *WebSocketMessage, 100),
                startTime: time.Now(),
                status: &amp;models.Agent{
                        AgentID:         cfg.AgentID,
                        Hostname:        hostname,
                        IP:              ip,
                        LogstashVersion: "unknown", // 将在启动时获取
                        Status:          "offline",
                        LastHeartbeat:   time.Now(),
                        AppliedConfigs:  []models.AppliedConfig{},
                },
        }
        
        return agent, nil</span>
}

// WithAPIClient 设置API客户端
func (a *Agent) WithAPIClient(client APIClient) *Agent <span class="cov0" title="0">{
        a.apiClient = client
        return a
}</span>

// WithConfigManager 设置配置管理器
func (a *Agent) WithConfigManager(mgr ConfigManager) *Agent <span class="cov0" title="0">{
        a.configMgr = mgr
        return a
}</span>

// WithLogstashController 设置Logstash控制器
func (a *Agent) WithLogstashController(ctrl LogstashController) *Agent <span class="cov0" title="0">{
        a.logstashCtrl = ctrl
        return a
}</span>

// WithHeartbeatService 设置心跳服务
func (a *Agent) WithHeartbeatService(service HeartbeatService) *Agent <span class="cov0" title="0">{
        a.heartbeat = service
        return a
}</span>

// WithMetricsCollector 设置指标收集器
func (a *Agent) WithMetricsCollector(collector MetricsCollector) *Agent <span class="cov0" title="0">{
        a.metrics = collector
        return a
}</span>

// Start 启动Agent
func (a *Agent) Start(ctx context.Context) error <span class="cov8" title="1">{
        a.logger.Info("正在启动Agent...")
        
        // 创建带取消的上下文
        a.ctx, a.cancel = context.WithCancel(ctx)
        
        // 验证组件
        if err := a.validateComponents(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("组件验证失败: %w", err)
        }</span>
        
        // 注册到管理平台
        <span class="cov8" title="1">if err := a.Register(a.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("注册到管理平台失败: %w", err)
        }</span>
        
        // 启动Logstash
        <span class="cov8" title="1">if err := a.logstashCtrl.Start(a.ctx); err != nil </span><span class="cov0" title="0">{
                a.logger.WithError(err).Error("启动Logstash失败")
                // 不返回错误，允许Agent继续运行
        }</span>
        
        // 获取Logstash版本
        <span class="cov8" title="1">if status, err := a.logstashCtrl.GetStatus(); err == nil </span><span class="cov8" title="1">{
                a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                        s.LogstashVersion = status.Version
                }</span>)
        }
        
        // 启动心跳服务
        <span class="cov8" title="1">if err := a.heartbeat.Start(a.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("启动心跳服务失败: %w", err)
        }</span>
        
        // 启动指标收集
        <span class="cov8" title="1">if err := a.metrics.Start(a.ctx); err != nil </span><span class="cov0" title="0">{
                a.logger.WithError(err).Error("启动指标收集失败")
                // 不返回错误，指标收集是可选功能
        }</span>
        
        // 启动WebSocket连接（如果启用）
        <span class="cov8" title="1">if a.config.EnableWebSocket </span><span class="cov8" title="1">{
                a.wg.Add(1)
                go a.connectWebSocket()
        }</span>
        
        // 启动消息处理
        <span class="cov8" title="1">a.wg.Add(1)
        go a.processMessages()
        
        // 更新状态为在线
        a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                s.Status = "online"
                s.LastHeartbeat = time.Now()
        }</span>)
        
        <span class="cov8" title="1">a.logger.Info("Agent启动成功")
        return nil</span>
}

// Stop 停止Agent
func (a *Agent) Stop(ctx context.Context) error <span class="cov8" title="1">{
        a.logger.Info("正在停止Agent...")
        
        // 更新状态为离线
        a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                s.Status = "offline"
        }</span>)
        
        // 发送最后的状态更新
        <span class="cov8" title="1">if a.apiClient != nil </span><span class="cov8" title="1">{
                if err := a.apiClient.ReportStatus(ctx, a.GetStatus()); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("发送离线状态失败")
                }</span>
        }
        
        // 取消上下文
        <span class="cov8" title="1">if a.cancel != nil </span><span class="cov8" title="1">{
                a.cancel()
        }</span>
        
        // 停止心跳服务
        <span class="cov8" title="1">if a.heartbeat != nil </span><span class="cov8" title="1">{
                if err := a.heartbeat.Stop(); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("停止心跳服务失败")
                }</span>
        }
        
        // 停止指标收集
        <span class="cov8" title="1">if a.metrics != nil </span><span class="cov8" title="1">{
                if err := a.metrics.Stop(); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("停止指标收集失败")
                }</span>
        }
        
        // 停止Logstash
        <span class="cov8" title="1">if a.logstashCtrl != nil </span><span class="cov8" title="1">{
                if err := a.logstashCtrl.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("停止Logstash失败")
                }</span>
        }
        
        // 关闭API客户端
        <span class="cov8" title="1">if a.apiClient != nil </span><span class="cov8" title="1">{
                if err := a.apiClient.Close(); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("关闭API客户端失败")
                }</span>
        }
        
        // 关闭消息通道
        <span class="cov8" title="1">close(a.msgChan)
        
        // 等待所有goroutine结束
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                a.wg.Wait()
                close(done)
        }</span>()
        
        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                a.logger.Info("Agent已停止")
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                a.logger.Warn("停止Agent超时")
                return ctx.Err()</span>
        }
}

// Register 注册到管理平台
func (a *Agent) Register(ctx context.Context) error <span class="cov8" title="1">{
        a.logger.Info("正在注册到管理平台...")
        
        // 发送注册请求
        if err := a.apiClient.Register(ctx, a.GetStatus()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("注册请求失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">a.logger.WithField("agent_id", a.config.AgentID).Info("注册成功")
        return nil</span>
}

// GetStatus 获取Agent状态
func (a *Agent) GetStatus() *models.Agent <span class="cov8" title="1">{
        a.statusMutex.RLock()
        defer a.statusMutex.RUnlock()
        
        // 创建状态副本
        status := *a.status
        
        // 复制切片
        status.AppliedConfigs = make([]models.AppliedConfig, len(a.status.AppliedConfigs))
        copy(status.AppliedConfigs, a.status.AppliedConfigs)
        
        return &amp;status
}</span>

// validateComponents 验证组件
func (a *Agent) validateComponents() error <span class="cov8" title="1">{
        if a.apiClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("API客户端未设置")
        }</span>
        <span class="cov8" title="1">if a.configMgr == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配置管理器未设置")
        }</span>
        <span class="cov8" title="1">if a.logstashCtrl == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Logstash控制器未设置")
        }</span>
        <span class="cov8" title="1">if a.heartbeat == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("心跳服务未设置")
        }</span>
        <span class="cov8" title="1">if a.metrics == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("指标收集器未设置")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// connectWebSocket 连接WebSocket
func (a *Agent) connectWebSocket() <span class="cov8" title="1">{
        defer a.wg.Done()
        
        retryCount := 0
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-a.ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }
                
                <span class="cov8" title="1">a.logger.Info("正在连接WebSocket...")
                
                // 连接WebSocket
                err := a.apiClient.ConnectWebSocket(a.ctx, a.config.AgentID, a)
                if err == nil </span><span class="cov0" title="0">{
                        // 连接成功，重置重试计数
                        retryCount = 0
                        a.logger.Info("WebSocket连接成功")
                        
                        // 等待连接断开
                        select </span>{
                        case &lt;-a.ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                } else<span class="cov8" title="1"> {
                        // 连接失败
                        retryCount++
                        a.logger.WithError(err).WithField("retry_count", retryCount).Error("WebSocket连接失败")
                        
                        // 检查是否超过最大重试次数
                        if a.config.MaxReconnectAttempts &gt; 0 &amp;&amp; retryCount &gt;= a.config.MaxReconnectAttempts </span><span class="cov0" title="0">{
                                a.logger.Error("WebSocket重连次数超过限制，停止重连")
                                return
                        }</span>
                        
                        // 等待一段时间后重试
                        <span class="cov8" title="1">select </span>{
                        case &lt;-time.After(a.config.ReconnectInterval):<span class="cov0" title="0"></span>
                        case &lt;-a.ctx.Done():<span class="cov8" title="1">
                                return</span>
                        }
                }
        }
}

// processMessages 处理消息
func (a *Agent) processMessages() <span class="cov8" title="1">{
        defer a.wg.Done()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case msg, ok := &lt;-a.msgChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        
                        <span class="cov8" title="1">if err := a.handleMessage(msg); err != nil </span><span class="cov0" title="0">{
                                a.logger.WithError(err).WithField("msg_type", msg.Type).Error("处理消息失败")
                        }</span>
                        
                case &lt;-a.ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// handleMessage 处理单个消息
func (a *Agent) handleMessage(msg *WebSocketMessage) error <span class="cov8" title="1">{
        a.logger.WithFields(logrus.Fields{
                "type":      msg.Type,
                "timestamp": msg.Timestamp,
        }).Debug("处理消息")
        
        switch msg.Type </span>{
        case MsgTypeConfigDeploy:<span class="cov0" title="0">
                return a.handleConfigDeploy(msg.Payload)</span>
        case MsgTypeConfigDelete:<span class="cov0" title="0">
                return a.handleConfigDelete(msg.Payload)</span>
        case MsgTypeReloadRequest:<span class="cov0" title="0">
                return a.handleReloadRequest()</span>
        case MsgTypeStatusRequest:<span class="cov8" title="1">
                return a.handleStatusRequest()</span>
        case MsgTypeMetricsRequest:<span class="cov0" title="0">
                return a.handleMetricsRequest()</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("未知消息类型: %s", msg.Type)</span>
        }
}

// HandleMessage 实现MessageHandler接口
func (a *Agent) HandleMessage(msgType string, payload []byte) error <span class="cov8" title="1">{
        msg := &amp;WebSocketMessage{
                Type:      msgType,
                Timestamp: time.Now(),
                Payload:   json.RawMessage(payload),
        }
        
        select </span>{
        case a.msgChan &lt;- msg:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("消息队列已满")</span>
        }
}

// OnConnect 实现MessageHandler接口
func (a *Agent) OnConnect() error <span class="cov8" title="1">{
        a.logger.Info("WebSocket连接建立")
        
        // 更新状态
        a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                s.Status = "online"
                s.LastHeartbeat = time.Now()
        }</span>)
        
        // 发送初始状态
        <span class="cov8" title="1">return a.handleStatusRequest()</span>
}

// OnDisconnect 实现MessageHandler接口
func (a *Agent) OnDisconnect(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                a.logger.WithError(err).Warn("WebSocket连接断开")
        }</span> else<span class="cov8" title="1"> {
                a.logger.Info("WebSocket连接正常关闭")
        }</span>
}

// 消息处理方法
func (a *Agent) handleConfigDeploy(payload json.RawMessage) error <span class="cov8" title="1">{
        // 解析配置部署请求
        var req struct {
                ConfigID string `json:"config_id"`
                Version  int    `json:"version"`
        }
        
        if err := json.Unmarshal(payload, &amp;req); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("解析配置部署请求失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">a.logger.WithFields(logrus.Fields{
                "config_id": req.ConfigID,
                "version":   req.Version,
        }).Info("收到配置部署请求")
        
        // 获取配置内容
        config, err := a.apiClient.GetConfig(a.ctx, req.ConfigID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取配置失败: %w", err)
        }</span>
        
        // 保存配置
        <span class="cov8" title="1">if err := a.configMgr.SaveConfig(config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("保存配置失败: %w", err)
        }</span>
        
        // 重载Logstash
        <span class="cov8" title="1">if a.config.EnableAutoReload &amp;&amp; a.logstashCtrl.IsRunning() </span><span class="cov8" title="1">{
                if err := a.logstashCtrl.Reload(a.ctx); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("重载Logstash失败")
                        // 不返回错误，允许继续
                }</span>
        }
        
        // 更新已应用配置
        <span class="cov8" title="1">applied := models.AppliedConfig{
                ConfigID:  req.ConfigID,
                Version:   req.Version,
                AppliedAt: time.Now(),
        }
        
        a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                // 检查是否已存在
                found := false
                for i, ac := range s.AppliedConfigs </span><span class="cov0" title="0">{
                        if ac.ConfigID == req.ConfigID </span><span class="cov0" title="0">{
                                s.AppliedConfigs[i] = applied
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        s.AppliedConfigs = append(s.AppliedConfigs, applied)
                }</span>
        })
        
        // 上报配置应用结果
        <span class="cov8" title="1">return a.apiClient.ReportConfigApplied(a.ctx, a.config.AgentID, &amp;applied)</span>
}

func (a *Agent) handleConfigDelete(payload json.RawMessage) error <span class="cov8" title="1">{
        // 解析配置删除请求
        var req struct {
                ConfigID string `json:"config_id"`
        }
        
        if err := json.Unmarshal(payload, &amp;req); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("解析配置删除请求失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">a.logger.WithField("config_id", req.ConfigID).Info("收到配置删除请求")
        
        // 删除配置
        if err := a.configMgr.DeleteConfig(req.ConfigID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("删除配置失败: %w", err)
        }</span>
        
        // 更新状态
        <span class="cov8" title="1">a.updateStatus(func(s *models.Agent) </span><span class="cov8" title="1">{
                // 从已应用配置中移除
                newConfigs := make([]models.AppliedConfig, 0, len(s.AppliedConfigs))
                for _, ac := range s.AppliedConfigs </span><span class="cov8" title="1">{
                        if ac.ConfigID != req.ConfigID </span><span class="cov0" title="0">{
                                newConfigs = append(newConfigs, ac)
                        }</span>
                }
                <span class="cov8" title="1">s.AppliedConfigs = newConfigs</span>
        })
        
        // 重载Logstash
        <span class="cov8" title="1">if a.config.EnableAutoReload &amp;&amp; a.logstashCtrl.IsRunning() </span><span class="cov8" title="1">{
                if err := a.logstashCtrl.Reload(a.ctx); err != nil </span><span class="cov0" title="0">{
                        a.logger.WithError(err).Error("重载Logstash失败")
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

func (a *Agent) handleReloadRequest() error <span class="cov8" title="1">{
        a.logger.Info("收到重载请求")
        
        if !a.logstashCtrl.IsRunning() </span><span class="cov8" title="1">{
                return fmt.Errorf("Logstash未运行")
        }</span>
        
        // 执行重载
        <span class="cov8" title="1">if err := a.logstashCtrl.Reload(a.ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("重载失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">a.logger.Info("Logstash重载成功")
        return nil</span>
}

func (a *Agent) handleStatusRequest() error <span class="cov8" title="1">{
        a.logger.Debug("收到状态请求")
        
        // 获取当前状态
        status := a.GetStatus()
        
        // 直接上报状态
        if err := a.apiClient.ReportStatus(a.ctx, status); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("上报状态失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

func (a *Agent) handleMetricsRequest() error <span class="cov8" title="1">{
        a.logger.Debug("收到指标请求")
        
        // 获取当前指标
        metrics, err := a.metrics.GetMetrics()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("获取指标失败: %w", err)
        }</span>
        
        // 上报指标
        <span class="cov8" title="1">if err := a.apiClient.ReportMetrics(a.ctx, a.config.AgentID, metrics); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("上报指标失败: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// updateStatus 更新Agent状态
func (a *Agent) updateStatus(updater func(*models.Agent)) <span class="cov8" title="1">{
        a.statusMutex.Lock()
        defer a.statusMutex.Unlock()
        updater(a.status)
}</span>

// 辅助函数

// getLocalIP 获取本机IP
func getLocalIP() (string, error) <span class="cov8" title="1">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov8" title="1">{
                        if ipnet.IP.To4() != nil </span><span class="cov8" title="1">{
                                return ipnet.IP.String(), nil
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return "", fmt.Errorf("未找到有效的IP地址")</span>
}

// getHostname 获取主机名
func getHostname() (string, error) <span class="cov8" title="1">{
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return hostname, nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package logstash

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/sirupsen/logrus"
        "logstash-platform/internal/agent/config"
        "logstash-platform/internal/agent/core"
)

// Controller Logstash控制器实现
type Controller struct {
        config        *config.AgentConfig
        logger        *logrus.Logger
        
        // 进程管理
        cmd           *exec.Cmd
        cmdMutex      sync.Mutex
        
        // 状态管理
        status        *core.LogstashStatus
        statusMutex   sync.RWMutex
        
        // 日志输出
        logChan       chan string
        errorChan     chan string
        
        // 控制通道
        stopChan      chan struct{}
        stoppedChan   chan struct{}
}

// NewController 创建Logstash控制器
func NewController(cfg *config.AgentConfig, logger *logrus.Logger) core.LogstashController <span class="cov8" title="1">{
        return &amp;Controller{
                config:      cfg,
                logger:      logger,
                logChan:     make(chan string, 100),
                errorChan:   make(chan string, 100),
                stopChan:    make(chan struct{}),
                stoppedChan: make(chan struct{}),
                status: &amp;core.LogstashStatus{
                        Running: false,
                },
        }
}</span>

// Start 启动Logstash
func (c *Controller) Start(ctx context.Context) error <span class="cov0" title="0">{
        c.cmdMutex.Lock()
        defer c.cmdMutex.Unlock()
        
        // 检查是否已经运行
        if c.IsRunning() </span><span class="cov0" title="0">{
                return fmt.Errorf("Logstash已经在运行")
        }</span>
        
        <span class="cov0" title="0">c.logger.Info("正在启动Logstash...")
        
        // 构建命令行参数
        args := c.buildArgs()
        
        // 创建命令
        cmd := exec.CommandContext(ctx, c.config.LogstashPath, args...)
        
        // 设置环境变量
        cmd.Env = append(os.Environ(),
                fmt.Sprintf("LS_JAVA_OPTS=-Xmx1g -Xms1g"),
                fmt.Sprintf("LOGSTASH_PATH_CONF=%s", c.config.ConfigDir),
                fmt.Sprintf("LOGSTASH_PATH_DATA=%s", c.config.DataDir),
                fmt.Sprintf("LOGSTASH_PATH_LOGS=%s", c.config.LogDir),
        )
        
        // 设置工作目录
        cmd.Dir = filepath.Dir(c.config.LogstashPath)
        
        // 获取输出管道
        stdout, err := cmd.StdoutPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建stdout管道失败: %w", err)
        }</span>
        
        <span class="cov0" title="0">stderr, err := cmd.StderrPipe()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("创建stderr管道失败: %w", err)
        }</span>
        
        // 启动进程
        <span class="cov0" title="0">if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("启动Logstash失败: %w", err)
        }</span>
        
        <span class="cov0" title="0">c.cmd = cmd
        
        // 更新状态
        c.updateStatus(func(s *core.LogstashStatus) </span><span class="cov0" title="0">{
                s.Running = true
                s.PID = cmd.Process.Pid
                s.StartTime = time.Now()
                s.ConfigPath = c.config.ConfigDir
        }</span>)
        
        // 启动日志处理
        <span class="cov0" title="0">go c.handleOutput(stdout, c.logChan)
        go c.handleOutput(stderr, c.errorChan)
        go c.processLogs()
        
        // 等待进程退出
        go c.waitForExit()
        
        // 等待启动完成
        if err := c.waitForStartup(ctx); err != nil </span><span class="cov0" title="0">{
                c.Stop(context.Background())
                return err
        }</span>
        
        // 获取版本信息
        <span class="cov0" title="0">c.detectVersion()
        
        c.logger.WithField("pid", cmd.Process.Pid).Info("Logstash启动成功")
        return nil</span>
}

// Stop 停止Logstash
func (c *Controller) Stop(ctx context.Context) error <span class="cov8" title="1">{
        c.cmdMutex.Lock()
        defer c.cmdMutex.Unlock()
        
        if c.cmd == nil || c.cmd.Process == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov0" title="0">c.logger.Info("正在停止Logstash...")
        
        // 发送停止信号
        close(c.stopChan)
        
        // 发送SIGTERM信号
        if err := c.cmd.Process.Signal(syscall.SIGTERM); err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).Warn("发送SIGTERM信号失败")
        }</span>
        
        // 等待进程退出
        <span class="cov0" title="0">done := make(chan error, 1)
        go func() </span><span class="cov0" title="0">{
                done &lt;- c.cmd.Wait()
        }</span>()
        
        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                c.logger.Info("Logstash已正常停止")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                // 超时，强制终止
                c.logger.Warn("停止超时，强制终止Logstash")
                if err := c.cmd.Process.Kill(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("强制终止失败: %w", err)
                }</span>
        }
        
        // 更新状态
        <span class="cov0" title="0">c.updateStatus(func(s *core.LogstashStatus) </span><span class="cov0" title="0">{
                s.Running = false
                s.PID = 0
        }</span>)
        
        // 等待日志处理结束
        <span class="cov0" title="0">select </span>{
        case &lt;-c.stoppedChan:<span class="cov0" title="0"></span>
        case &lt;-time.After(5 * time.Second):<span class="cov0" title="0"></span>
        }
        
        <span class="cov0" title="0">c.cmd = nil
        return nil</span>
}

// Restart 重启Logstash
func (c *Controller) Restart(ctx context.Context) error <span class="cov0" title="0">{
        c.logger.Info("正在重启Logstash...")
        
        // 停止
        if err := c.Stop(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("停止Logstash失败: %w", err)
        }</span>
        
        // 等待一段时间
        <span class="cov0" title="0">time.Sleep(2 * time.Second)
        
        // 启动
        if err := c.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("启动Logstash失败: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// Reload 重新加载配置
func (c *Controller) Reload(ctx context.Context) error <span class="cov8" title="1">{
        if !c.IsRunning() </span><span class="cov8" title="1">{
                return fmt.Errorf("Logstash未运行")
        }</span>
        
        <span class="cov0" title="0">c.logger.Info("正在重载Logstash配置...")
        
        // 发送SIGHUP信号触发重载
        c.cmdMutex.Lock()
        cmd := c.cmd
        c.cmdMutex.Unlock()
        
        if cmd == nil || cmd.Process == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("进程不存在")
        }</span>
        
        <span class="cov0" title="0">if err := cmd.Process.Signal(syscall.SIGHUP); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("发送重载信号失败: %w", err)
        }</span>
        
        // 更新状态
        <span class="cov0" title="0">c.updateStatus(func(s *core.LogstashStatus) </span><span class="cov0" title="0">{
                s.LastReloadTime = time.Now()
        }</span>)
        
        <span class="cov0" title="0">c.logger.Info("配置重载信号已发送")
        return nil</span>
}

// IsRunning 检查是否运行中
func (c *Controller) IsRunning() bool <span class="cov8" title="1">{
        c.statusMutex.RLock()
        defer c.statusMutex.RUnlock()
        return c.status.Running
}</span>

// GetStatus 获取Logstash状态
func (c *Controller) GetStatus() (*core.LogstashStatus, error) <span class="cov8" title="1">{
        c.statusMutex.RLock()
        defer c.statusMutex.RUnlock()
        
        // 创建状态副本
        status := *c.status
        return &amp;status, nil
}</span>

// ValidateConfig 验证配置文件
func (c *Controller) ValidateConfig(configPath string) error <span class="cov0" title="0">{
        c.logger.WithField("path", configPath).Info("验证配置文件")
        
        // 构建验证命令
        args := []string{
                "--config.test_and_exit",
                "--path.config", configPath,
        }
        
        // 执行验证
        cmd := exec.Command(c.config.LogstashPath, args...)
        output, err := cmd.CombinedOutput()
        
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配置验证失败: %s\n%s", err, string(output))
        }</span>
        
        // 检查输出中是否包含错误
        <span class="cov0" title="0">outputStr := string(output)
        if strings.Contains(outputStr, "ERROR") || strings.Contains(outputStr, "error") </span><span class="cov0" title="0">{
                return fmt.Errorf("配置包含错误:\n%s", outputStr)
        }</span>
        
        <span class="cov0" title="0">c.logger.Info("配置验证通过")
        return nil</span>
}

// 内部方法

// buildArgs 构建命令行参数
func (c *Controller) buildArgs() []string <span class="cov0" title="0">{
        args := []string{
                "--path.config", c.config.ConfigDir,
                "--path.data", c.config.DataDir,
                "--path.logs", c.config.LogDir,
        }
        
        // 设置工作线程数
        if c.config.PipelineWorkers &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "--pipeline.workers", fmt.Sprintf("%d", c.config.PipelineWorkers))
        }</span>
        
        // 设置批处理大小
        <span class="cov0" title="0">if c.config.BatchSize &gt; 0 </span><span class="cov0" title="0">{
                args = append(args, "--pipeline.batch.size", fmt.Sprintf("%d", c.config.BatchSize))
        }</span>
        
        // 启用配置重载
        <span class="cov0" title="0">if c.config.EnableAutoReload </span><span class="cov0" title="0">{
                args = append(args, "--config.reload.automatic")
                args = append(args, "--config.reload.interval", "3s")
        }</span>
        
        <span class="cov0" title="0">return args</span>
}

// handleOutput 处理输出
func (c *Controller) handleOutput(pipe io.ReadCloser, output chan&lt;- string) <span class="cov0" title="0">{
        defer pipe.Close()
        
        scanner := bufio.NewScanner(pipe)
        for scanner.Scan() </span><span class="cov0" title="0">{
                select </span>{
                case output &lt;- scanner.Text():<span class="cov0" title="0"></span>
                        // 成功发送
                case &lt;-c.stopChan:<span class="cov0" title="0">
                        return</span>
                }
        }
}

// processLogs 处理日志
func (c *Controller) processLogs() <span class="cov0" title="0">{
        defer close(c.stoppedChan)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case line := &lt;-c.logChan:<span class="cov0" title="0">
                        c.logger.WithField("source", "logstash").Debug(line)
                        // 检测启动完成
                        if strings.Contains(line, "Pipelines running") </span><span class="cov0" title="0">{
                                c.logger.Info("Logstash管道已启动")
                        }</span>
                        
                case line := &lt;-c.errorChan:<span class="cov0" title="0">
                        c.logger.WithField("source", "logstash").Error(line)</span>
                        
                case &lt;-c.stopChan:<span class="cov0" title="0">
                        // 清空剩余日志
                        for len(c.logChan) &gt; 0 </span><span class="cov0" title="0">{
                                &lt;-c.logChan
                        }</span>
                        <span class="cov0" title="0">for len(c.errorChan) &gt; 0 </span><span class="cov0" title="0">{
                                &lt;-c.errorChan
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }
}

// waitForExit 等待进程退出
func (c *Controller) waitForExit() <span class="cov0" title="0">{
        c.cmdMutex.Lock()
        cmd := c.cmd
        c.cmdMutex.Unlock()
        
        if cmd == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // 等待进程退出
        <span class="cov0" title="0">err := cmd.Wait()
        
        c.logger.WithError(err).Info("Logstash进程已退出")
        
        // 更新状态
        c.updateStatus(func(s *core.LogstashStatus) </span><span class="cov0" title="0">{
                s.Running = false
                s.PID = 0
        }</span>)
}

// waitForStartup 等待启动完成
func (c *Controller) waitForStartup(ctx context.Context) error <span class="cov0" title="0">{
        startupTimeout := 60 * time.Second
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        deadline := time.Now().Add(startupTimeout)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // 检查进程是否还在运行
                        if !c.IsRunning() </span><span class="cov0" title="0">{
                                return fmt.Errorf("Logstash启动失败")
                        }</span>
                        
                        // TODO: 检查Logstash API或日志确认启动完成
                        // 暂时使用简单的时间等待
                        <span class="cov0" title="0">if time.Now().After(deadline) </span><span class="cov0" title="0">{
                                return fmt.Errorf("启动超时")
                        }</span>
                        
                        // 假设5秒后启动完成
                        <span class="cov0" title="0">if time.Since(c.status.StartTime) &gt; 5*time.Second </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
        }
}

// detectVersion 检测Logstash版本
func (c *Controller) detectVersion() <span class="cov0" title="0">{
        // 执行版本命令
        cmd := exec.Command(c.config.LogstashPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).Warn("获取Logstash版本失败")
                return
        }</span>
        
        // 解析版本
        <span class="cov0" title="0">version := strings.TrimSpace(string(output))
        if parts := strings.Fields(version); len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                version = parts[1]
        }</span>
        
        <span class="cov0" title="0">c.updateStatus(func(s *core.LogstashStatus) </span><span class="cov0" title="0">{
                s.Version = version
        }</span>)
        
        <span class="cov0" title="0">c.logger.WithField("version", version).Info("检测到Logstash版本")</span>
}

// updateStatus 更新状态
func (c *Controller) updateStatus(updater func(*core.LogstashStatus)) <span class="cov0" title="0">{
        c.statusMutex.Lock()
        defer c.statusMutex.Unlock()
        updater(c.status)
}</span>

// GetLogContent 获取日志内容（用于调试）
func (c *Controller) GetLogContent(lines int) ([]string, error) <span class="cov0" title="0">{
        logFile := filepath.Join(c.config.LogDir, "logstash-plain.log")
        
        file, err := os.Open(logFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("打开日志文件失败: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        // 读取最后N行
        var result []string
        scanner := bufio.NewScanner(file)
        for scanner.Scan() </span><span class="cov0" title="0">{
                result = append(result, scanner.Text())
                if len(result) &gt; lines </span><span class="cov0" title="0">{
                        result = result[1:]
                }</span>
        }
        
        <span class="cov0" title="0">return result, scanner.Err()</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
